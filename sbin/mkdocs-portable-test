#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.8"
# dependencies = [
#     "requests>=2.31.0",
# ]
# ///
"""
Test Portable MkDocs Electron Desktop App

This script performs comprehensive testing of portable MkDocs desktop applications
created by mkdocs-portable. It validates project structure, site content, offline
assets, HTTP endpoints, and Electron app functionality.

Features:
- Tests Electron project structure and configuration
- Validates MkDocs site content and assets
- Tests offline asset availability
- Starts HTTP server and tests endpoints
- Tests Electron app startup
- Validates build artifacts

Usage:
  mkdocs-portable-test --target-folder TARGET [options]

Examples:
  # Test a portable desktop app
  mkdocs-portable-test --target-folder desktop-app/mytalent-docs

  # Quick tests only (skip Electron startup)
  mkdocs-portable-test --target-folder portable_docs --quick

  # Test with custom site directory
  mkdocs-portable-test --target-folder my-app --site-subdir build

Perfect for validating portable MkDocs desktop applications before distribution!
"""

import json
import subprocess
import sys
import time
from pathlib import Path
from urllib.parse import urljoin

try:
    import requests
except ImportError:
    print("❌ Error: requests library not available")
    print("   This should not happen with inline dependencies")
    sys.exit(1)


class PortableAppTester:
    def __init__(self, target_dir: Path, site_subdir: str = "mkdocs"):
        self.target_dir = target_dir
        self.site_dir = target_dir / site_subdir
        self.test_results = []
        self.server_process = None
        self.base_url = None
        
    def log_test(self, test_name: str, passed: bool, message: str = ""):
        """Log a test result."""
        status = "✅ PASS" if passed else "❌ FAIL"
        print(f"{status}: {test_name}")
        if message:
            print(f"    {message}")
        
        self.test_results.append({
            "test": test_name,
            "passed": passed,
            "message": message
        })
        
        if not passed:
            print(f"    ❌ Test failed: {test_name}")
    
    def test_project_structure(self):
        """Test that all required project files exist."""
        print("\n=== Testing Project Structure ===")
        
        required_files = [
            "package.json",
            "electron/main.js",
            "mkdocs.yml"
        ]
        
        for file_path in required_files:
            full_path = self.target_dir / file_path
            exists = full_path.exists()
            self.log_test(f"File exists: {file_path}", exists)
            
        # Test package.json content
        try:
            package_json = self.target_dir / "package.json"
            if package_json.exists():
                with open(package_json, "r") as f:
                    package_data = json.load(f)
                
                required_fields = ["name", "version", "main", "scripts", "devDependencies"]
                for field in required_fields:
                    has_field = field in package_data
                    self.log_test(f"package.json has {field}", has_field)
                    
                # Check for required dependencies
                dev_deps = package_data.get("devDependencies", {})
                has_electron = "electron" in dev_deps
                has_builder = "electron-builder" in dev_deps
                
                self.log_test("Has electron dependency", has_electron)
                self.log_test("Has electron-builder dependency", has_builder)
            else:
                self.log_test("package.json exists", False)
                
        except Exception as e:
            self.log_test("package.json is valid JSON", False, str(e))
    
    def test_site_content(self):
        """Test that the MkDocs site content is properly included."""
        print("\n=== Testing Site Content ===")
        
        # Check for essential MkDocs files
        essential_files = [
            "index.md",
        ]
        
        for file_path in essential_files:
            full_path = self.site_dir / file_path
            exists = full_path.exists()
            self.log_test(f"Site file exists: {file_path}", exists)
        
        # Check for MkDocs config
        mkdocs_yml = self.target_dir / "mkdocs.yml"
        self.log_test("mkdocs.yml exists", mkdocs_yml.exists())
        
        # Count markdown files
        md_files = list(self.site_dir.glob("**/*.md"))
        has_content = len(md_files) > 0
        self.log_test(f"Has markdown content ({len(md_files)} files)", has_content)
    
    def test_offline_assets(self):
        """Test that assets are available for offline use."""
        print("\n=== Testing Offline Assets ===")
        
        # Check for common asset directories
        asset_dirs = [
            self.site_dir / "assets",
            self.site_dir / "javascripts",
            self.site_dir / "stylesheets"
        ]
        
        for asset_dir in asset_dirs:
            if asset_dir.exists():
                files = list(asset_dir.glob("**/*"))
                file_count = len([f for f in files if f.is_file()])
                self.log_test(f"Assets in {asset_dir.name}/", file_count > 0, f"{file_count} files")
    
    def start_test_server(self):
        """Start a test HTTP server to validate the app functionality."""
        print("\n=== Starting Test Server ===")
        
        # Check if there's a built site directory
        potential_site_dirs = [
            self.target_dir / "site",
            self.site_dir
        ]
        
        site_to_serve = None
        for site_dir in potential_site_dirs:
            index_html = site_dir / "index.html"
            if index_html.exists():
                site_to_serve = site_dir
                break
        
        if not site_to_serve:
            self.log_test("Test server startup", False, "No built site found (index.html missing)")
            return None
        
        try:
            import http.server
            import socketserver
            import threading
            
            class TestHandler(http.server.SimpleHTTPRequestHandler):
                def __init__(self, *args, **kwargs):
                    super().__init__(*args, directory=str(site_to_serve), **kwargs)
                
                def log_message(self, format, *args):
                    # Suppress server logs during testing
                    pass
            
            # Find an available port
            with socketserver.TCPServer(("localhost", 0), TestHandler) as httpd:
                port = httpd.server_address[1]
                self.base_url = f"http://localhost:{port}"
                
                # Start server in background thread
                server_thread = threading.Thread(target=httpd.serve_forever)
                server_thread.daemon = True
                server_thread.start()
                
                self.log_test("Test server started", True, f"Running on {self.base_url}")
                
                # Give server time to start
                time.sleep(1)
                
                return httpd
                
        except Exception as e:
            self.log_test("Test server startup", False, str(e))
            return None
    
    def test_http_endpoints(self, server):
        """Test HTTP endpoints and content delivery."""
        print("\n=== Testing HTTP Endpoints ===")
        
        if not self.base_url:
            self.log_test("HTTP endpoint testing", False, "No test server available")
            return
        
        # Test main page
        try:
            response = requests.get(self.base_url, timeout=5)
            self.log_test("Main page loads", response.status_code == 200)
            
            if response.status_code == 200:
                content = response.text
                has_content = len(content) > 500  # Should have substantial content
                self.log_test("Main page has content", has_content)
                
        except Exception as e:
            self.log_test("Main page request", False, str(e))
        
        # Test search index if it exists
        try:
            search_url = urljoin(self.base_url, "/search/search_index.json")
            response = requests.get(search_url, timeout=5)
            if response.status_code == 200:
                self.log_test("Search index accessible", True)
                search_data = response.json()
                has_docs = "docs" in search_data and len(search_data["docs"]) > 0
                self.log_test("Search index has documents", has_docs)
            else:
                self.log_test("Search index accessible", False, "Not found (may be OK)")
                
        except Exception as e:
            # Search index might not exist, which is OK
            pass
    
    def test_electron_app_startup(self):
        """Test that the Electron app can start without errors."""
        print("\n=== Testing Electron App Startup ===")
        
        if not (self.target_dir / "node_modules").exists():
            self.log_test("Electron app startup", False, "Dependencies not installed (run: npm install)")
            return
        
        try:
            # Try to start the app for a short time
            process = subprocess.Popen(
                ["npm", "start"],
                cwd=self.target_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Wait a few seconds for startup
            time.sleep(3)
            
            # Check if process is still running (good sign)
            if process.poll() is None:
                self.log_test("Electron app starts successfully", True)
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
            else:
                stdout, stderr = process.communicate()
                self.log_test("Electron app startup", False, f"Process exited early")
                
        except Exception as e:
            self.log_test("Electron app startup test", False, str(e))
    
    def test_build_artifacts(self):
        """Test that build artifacts are created properly."""
        print("\n=== Testing Build Artifacts ===")
        
        dist_dir = self.target_dir / "dist"
        
        if not dist_dir.exists():
            self.log_test("Build artifacts exist", False, "No dist directory (run build first)")
            return
        
        # Check for platform-specific artifacts
        artifacts = list(dist_dir.glob("*"))
        has_artifacts = len(artifacts) > 0
        self.log_test("Build artifacts created", has_artifacts)
        
        if has_artifacts:
            for artifact in artifacts:
                if artifact.is_file():
                    size_mb = artifact.stat().st_size / (1024 * 1024)
                    reasonable_size = size_mb > 10  # Should be at least 10MB
                    self.log_test(f"Artifact size reasonable: {artifact.name}", reasonable_size, f"{size_mb:.1f}MB")
    
    def run_all_tests(self, site_name: str = "Portable MkDocs App"):
        """Run all tests and return overall result."""
        print(f"{site_name} - Test Suite")
        print("=" * 60)
        
        # Run tests
        self.test_project_structure()
        self.test_site_content()
        self.test_offline_assets()
        
        # Start server for HTTP tests
        server = self.start_test_server()
        if server:
            self.test_http_endpoints(server)
            server.shutdown()
        
        self.test_electron_app_startup()
        self.test_build_artifacts()
        
        # Summary
        print("\n" + "=" * 60)
        print("TEST SUMMARY")
        print("=" * 60)
        
        passed = sum(1 for result in self.test_results if result["passed"])
        total = len(self.test_results)
        
        print(f"Tests passed: {passed}/{total}")
        
        if passed == total:
            print("🎉 All tests passed!")
            return True
        else:
            print("❌ Some tests failed:")
            for result in self.test_results:
                if not result["passed"]:
                    print(f"  - {result['test']}: {result['message']}")
            return False


def parse_args():
    """Parse command line arguments."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Test portable MkDocs Electron desktop application",
        epilog="Examples:\n"
               "  mkdocs-portable-test --target-folder desktop-app/my-docs\n"
               "  mkdocs-portable-test --target-folder portable_docs --quick\n"
               "  mkdocs-portable-test --target-folder my-app --site-subdir content",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "--target-folder",
        required=True,
        help="Target folder containing the portable Electron app"
    )
    parser.add_argument(
        "--site-subdir",
        default="mkdocs",
        help="Subdirectory containing MkDocs source (default: mkdocs)"
    )
    parser.add_argument(
        "--site-name",
        default="Portable MkDocs App",
        help="Name of the site for display purposes"
    )
    parser.add_argument(
        "--quick",
        action="store_true",
        help="Run only quick tests (skip Electron startup test)"
    )
    
    return parser.parse_args()


def main():
    """Main test runner."""
    args = parse_args()
    
    target_dir = Path(args.target_folder).resolve()
    
    # Check if target directory exists
    if not target_dir.exists():
        print(f"❌ Target folder not found: {target_dir}")
        print("   Create a portable app first using mkdocs-portable")
        sys.exit(1)
    
    tester = PortableAppTester(target_dir, args.site_subdir)
    
    if args.quick:
        print(f"Running quick tests for: {target_dir}")
        print("=" * 60)
        tester.test_project_structure()
        tester.test_site_content()
        tester.test_offline_assets()
        
        passed = sum(1 for result in tester.test_results if result["passed"])
        total = len(tester.test_results)
        success = passed == total
        
        print(f"\nQuick tests: {passed}/{total} passed")
    else:
        success = tester.run_all_tests(args.site_name)
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
